name: Heartbeat Preview

on:
  pull_request:
    branches: [main, master]
    paths:
      - 'src/services/heartbeat.ts'
      - 'src/commands/status.ts'
      - 'src/commands/status-details.ts'
      - 'src/jobs/**'
      - '.github/workflows/heartbeat-preview.yml'

jobs:
  heartbeat-check:
    name: Heartbeat Check
    runs-on: ubuntu-latest
    
    services:
      # Mock service for testing
      mock-api:
        image: mockserver/mockserver:latest
        ports:
          - 8080:1080
        env:
          MOCKSERVER_INITIALIZATION_JSON_PATH: /config/initializerJson.json
        volumes:
          - ./test/mocks/mock-api.json:/config/initializerJson.json
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18.x'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run tests
        run: npm test
      
      - name: Run heartbeat checks
        run: |
          # Set up test environment variables
          echo "SERVICES='[{\"name\":\"mock-api\",\"url\":\"http://localhost:8080/health\"}]'" >> $GITHUB_ENV
          echo "HEARTBEAT_INTERVAL=1000" >> $GITHUB_ENV
          echo "HEARTBEAT_TIMEOUT=5000" >> $GITHUB_ENV
          
          # Run heartbeat checks
          npx ts-node test/scripts/run-heartbeat-checks.ts
        
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: heartbeat-results
          path: test-results/
          if-no-files-found: ignore
          retention-days: 1

      - name: Comment on PR
        uses: actions/github-script@v6
        if: github.event_name == 'pull_request' && github.actor != 'dependabot[bot]'
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const fs = require('fs');
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            // Check if the PR is from a fork
            if (pr.head.repo.fork) {
              console.log('Skipping comment on forked PR');
              return;
            }
            
            // Check if the PR has the 'skip-heartbeat' label
            const hasSkipLabel = pr.labels.some(label => label.name === 'skip-heartbeat');
            if (hasSkipLabel) {
              console.log('Skipping heartbeat checks due to skip-heartbeat label');
              return;
            }
            
            // Read test results if available
            let testResults = '';
            try {
              testResults = fs.readFileSync('test-results/heartbeat-results.md', 'utf8');
            } catch (error) {
              testResults = 'No test results available. Check the workflow logs for details.';
            }
            
            // Create or update comment
            const comment = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `### 🔍 Heartbeat Check Results\n\n${testResults}\n\n*This comment was automatically generated by the Serafina bot.*`
            };
            
            // Check for existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const existingComment = comments.find(c => 
              c.user.login === 'github-actions[bot]' && 
              c.body.includes('### 🔍 Heartbeat Check Results')
            );
            
            if (existingComment) {
              await github.rest.issues.updateComment({
                ...comment,
                comment_id: existingComment.id
              });
            } else {
              await github.rest.issues.createComment(comment);
            }
