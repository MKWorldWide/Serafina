/**
 * Service Worker for GameDin
 * 
 * This service worker provides offline capabilities for the application through:
 * - Precaching of essential application assets
 * - Runtime caching of API requests
 * - Background sync for offline operations
 * - Cache management and expiration
 * 
 * Powered by Workbox (https://developers.google.com/web/tools/workbox)
 */

import { clientsClaim } from 'workbox-core';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { StaleWhileRevalidate, NetworkFirst, CacheFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { BackgroundSyncPlugin } from 'workbox-background-sync';

declare let self: ServiceWorkerGlobalScope;

// Claim any currently available clients once the service worker becomes active
clientsClaim();

// Precache all assets generated by the build process
precacheAndRoute(self.__WB_MANIFEST);

// Cache GraphQL API requests
const apiCacheName = 'api-cache-v1';
const apiExpirationPlugin = new ExpirationPlugin({
  maxEntries: 50, // Maximum number of entries to cache
  maxAgeSeconds: 24 * 60 * 60, // 1 day
  purgeOnQuotaError: true // Automatically purge when storage quota is exceeded
});

// Create a background sync instance for offline message sending
const messageSyncPlugin = new BackgroundSyncPlugin('message-queue', {
  maxRetentionTime: 24 * 60, // Retry for 24 hours (in minutes)
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request);
        console.log('Replayed message synchronization successfully!');
      } catch (error) {
        console.error('Replay failed for message request', error);
        
        // If the request failed, put it back in the queue
        await queue.unshiftRequest(entry);
        
        // Re-throw the error to trigger a retry
        throw error;
      }
    }
  }
});

// Cache API routes with a network-first strategy
registerRoute(
  // Match API requests
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: apiCacheName,
    plugins: [apiExpirationPlugin]
  })
);

// Cache GraphQL queries with a stale-while-revalidate strategy
registerRoute(
  ({ url }) => url.pathname.includes('/graphql') && url.searchParams.get('operationName') === 'query',
  new StaleWhileRevalidate({
    cacheName: 'graphql-queries-cache',
    plugins: [apiExpirationPlugin]
  })
);

// Cache GraphQL mutations with background sync for offline support
registerRoute(
  ({ url }) => url.pathname.includes('/graphql') && url.searchParams.get('operationName') === 'mutation',
  async ({ event }) => {
    const fetchEvent = event as FetchEvent;
    try {
      // Try to send the mutation to the server
      const response = await fetch(fetchEvent.request.clone());
      return response;
    } catch (error) {
      // If offline, add to background sync queue
      await messageSyncPlugin.fetchDidFail.call(messageSyncPlugin, {
        request: fetchEvent.request.clone(),
        event: fetchEvent,
        state: {}
      });
      
      // Return a mock success response for better UX
      return new Response(JSON.stringify({
        data: null,
        errors: [{ message: 'Currently offline. Your changes will sync when you are back online.' }]
      }), {
        headers: { 'Content-Type': 'application/json' }
      });
    }
  }
);

// Cache images with a cache-first strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        purgeOnQuotaError: true
      })
    ]
  })
);

// Cache fonts with a cache-first strategy
registerRoute(
  ({ request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: 'fonts-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 24 * 60 * 60, // 60 days
        purgeOnQuotaError: true
      })
    ]
  })
);

// Cache static assets with a stale-while-revalidate strategy
registerRoute(
  ({ request }) => 
    request.destination === 'script' || 
    request.destination === 'style',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 24 * 60 * 60, // 1 day
        purgeOnQuotaError: true
      })
    ]
  })
);

// This handles single-page application navigation
// All navigation requests will serve the same HTML content from the cache
const handler = createHandlerBoundToURL('/index.html');
const navigationRoute = new NavigationRoute(handler, {
  // Don't serve these URLs through the handler for SPA navigation
  denylist: [
    // Exclude API routes
    new RegExp('^/api/'),
    // Exclude GraphQL endpoints
    new RegExp('^/graphql'),
    // Exclude asset files
    new RegExp('\\.(css|js|png|jpg|jpeg|gif|svg|ico)$')
  ]
});
registerRoute(navigationRoute);

// Listen for message events to skip waiting
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Handle fetch failures for offline detection
self.addEventListener('fetch', (event) => {
  const request = event.request;
  
  // Only handle API and GraphQL fetch failures
  if (!request.url.includes('/api/') && !request.url.includes('/graphql')) {
    return;
  }
  
  event.respondWith(
    fetch(request).catch(() => {
      // If we're offline and not a mutation, try to serve from cache
      if (
        !request.url.includes('mutation') &&
        (request.method === 'GET' || request.method === 'HEAD')
      ) {
        return caches.match(request);
      }
      
      // Otherwise, return an error response
      return new Response(JSON.stringify({
        error: 'You are currently offline',
        isOffline: true
      }), {
        status: 503,
        headers: { 'Content-Type': 'application/json' }
      });
    })
  );
}); 